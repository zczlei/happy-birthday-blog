"use client"

import { useState, useEffect } from "react"
import { useParams, useRouter } from "next/navigation"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { ArrowLeft, Clock, User, Eye, Share2, Bookmark, ThumbsUp, MessageCircle } from "lucide-react"
import Image from "next/image"

interface BlogPost {
  id: number
  title: string
  excerpt: string
  content: string
  tags: string[]
  author: string
  publishedAt: string
  readTime: string
  image: string
  featured: boolean
  views: number
  likes: number
  comments: Comment[]
}

interface Comment {
  id: number
  author: string
  content: string
  publishedAt: string
  likes: number
}

// Mock data for blog posts
const getBlogById = (id: string): BlogPost | null => {
  const posts: Record<string, BlogPost> = {
    "1": {
      id: 1,
      title: "The Complete Guide to DeFi Yield Farming",
      excerpt: "Learn everything you need to know about yield farming in decentralized finance.",
      content: `
        <p>Yield farming has become one of the most popular ways to earn passive income in the decentralized finance (DeFi) ecosystem. This comprehensive guide will walk you through everything you need to know to get started with yield farming safely and effectively.</p>
        
        <h2>What is Yield Farming?</h2>
        <p>Yield farming, also known as liquidity mining, is the practice of lending or staking cryptocurrency tokens to generate high returns or rewards in the form of additional cryptocurrency. It involves providing liquidity to decentralized exchanges (DEXs) and other DeFi protocols in exchange for rewards.</p>
        
        <h2>How Yield Farming Works</h2>
        <p>The basic concept is simple: you deposit your crypto assets into a liquidity pool, and in return, you earn rewards. These rewards can come in various forms:</p>
        <ul>
          <li><strong>Trading fees:</strong> A portion of the fees generated by trades in the pool</li>
          <li><strong>Governance tokens:</strong> Native tokens of the protocol</li>
          <li><strong>Additional yield:</strong> Bonus rewards for participating in specific pools</li>
        </ul>
        
        <h2>Popular Yield Farming Strategies</h2>
        <h3>1. Liquidity Provision</h3>
        <p>The most straightforward strategy involves providing liquidity to automated market makers (AMMs) like Uniswap, SushiSwap, or PancakeSwap. You deposit two tokens in equal value to create a liquidity pair.</p>
        
        <h3>2. Lending and Borrowing</h3>
        <p>Platforms like Aave and Compound allow you to lend your assets to earn interest, or borrow against your collateral to access additional capital for farming.</p>
        
        <h3>3. Staking</h3>
        <p>Many protocols offer staking rewards for holding and staking their native tokens. This is often the safest form of yield farming.</p>
        
        <h2>Risks to Consider</h2>
        <p>While yield farming can be profitable, it's important to understand the risks:</p>
        <ul>
          <li><strong>Impermanent Loss:</strong> When providing liquidity, you may lose value if token prices diverge significantly</li>
          <li><strong>Smart Contract Risk:</strong> Bugs or exploits in smart contracts can lead to loss of funds</li>
          <li><strong>Regulatory Risk:</strong> Changing regulations could affect the viability of certain protocols</li>
          <li><strong>Market Risk:</strong> Cryptocurrency prices are volatile and can affect your returns</li>
        </ul>
        
        <h2>Getting Started</h2>
        <p>To begin yield farming, you'll need:</p>
        <ol>
          <li>A Web3 wallet like MetaMask</li>
          <li>Cryptocurrency to deposit (start small while learning)</li>
          <li>ETH for gas fees (on Ethereum) or BNB (on BSC)</li>
          <li>Research on reputable protocols and current yields</li>
        </ol>
        
        <h2>Best Practices</h2>
        <ul>
          <li>Start with established, audited protocols</li>
          <li>Diversify across multiple pools and strategies</li>
          <li>Monitor your positions regularly</li>
          <li>Keep track of gas fees and ensure they don't eat into profits</li>
          <li>Stay informed about protocol updates and market conditions</li>
        </ul>
        
        <h2>Conclusion</h2>
        <p>Yield farming can be a rewarding way to put your crypto assets to work, but it requires careful research and risk management. Start small, learn the basics, and gradually increase your involvement as you become more comfortable with the ecosystem.</p>
      `,
      tags: ["DeFi", "Yield Farming", "Tutorial", "Beginner"],
      author: "Alex Thompson",
      publishedAt: "2024-01-10",
      readTime: "12 min read",
      image: "/blog-defi-guide.png",
      featured: true,
      views: 24680,
      likes: 892,
      comments: [
        {
          id: 1,
          author: "CryptoNewbie",
          content:
            "Great guide! This really helped me understand the basics of yield farming. Starting with small amounts as suggested.",
          publishedAt: "2024-01-11",
          likes: 15,
        },
        {
          id: 2,
          author: "DeFiExpert",
          content:
            "Excellent breakdown of the risks involved. Too many people jump into yield farming without understanding impermanent loss.",
          publishedAt: "2024-01-11",
          likes: 23,
        },
      ],
    },
    "2": {
      id: 2,
      title: "Smart Contract Security: Best Practices for Developers",
      excerpt: "Essential security practices every smart contract developer should follow.",
      content: `
        <p>Smart contract security is paramount in the blockchain ecosystem. A single vulnerability can lead to millions of dollars in losses. This guide covers essential security practices that every smart contract developer should implement.</p>
        
        <h2>Common Vulnerabilities</h2>
        <h3>Reentrancy Attacks</h3>
        <p>One of the most famous vulnerabilities, reentrancy occurs when a contract calls an external contract before updating its internal state. The external contract can then call back into the original contract, potentially draining funds.</p>
        
        <h3>Integer Overflow/Underflow</h3>
        <p>Before Solidity 0.8.0, arithmetic operations could overflow or underflow without reverting, leading to unexpected behavior.</p>
        
        <h3>Access Control Issues</h3>
        <p>Improperly implemented access controls can allow unauthorized users to execute privileged functions.</p>
        
        <h2>Security Best Practices</h2>
        <h3>1. Use Established Patterns</h3>
        <p>Leverage well-tested patterns like OpenZeppelin's contracts for common functionality such as access control, token standards, and security utilities.</p>
        
        <h3>2. Implement Proper Access Controls</h3>
        <p>Use role-based access control and ensure that sensitive functions are properly protected.</p>
        
        <h3>3. Follow the Checks-Effects-Interactions Pattern</h3>
        <p>Always perform checks first, then update state, and finally interact with external contracts.</p>
        
        <h2>Testing and Auditing</h2>
        <p>Comprehensive testing and professional audits are crucial for smart contract security. Consider both unit tests and integration tests, and always have your contracts audited by reputable security firms before mainnet deployment.</p>
      `,
      tags: ["Smart Contracts", "Security", "Development", "Best Practices"],
      author: "Dr. Sarah Kim",
      publishedAt: "2024-01-08",
      readTime: "15 min read",
      image: "/blog-security.png",
      featured: false,
      views: 18340,
      likes: 567,
      comments: [
        {
          id: 1,
          author: "DevSecOps",
          content:
            "This should be required reading for all smart contract developers. Security should never be an afterthought.",
          publishedAt: "2024-01-09",
          likes: 31,
        },
      ],
    },
  }

  return posts[id] || null
}

const relatedPosts = [
  {
    id: 3,
    title: "Understanding Gas Optimization Techniques",
    tags: ["Development", "Gas"],
    readTime: "8 min",
    image: "/blog-gas-optimization.png",
  },
  {
    id: 4,
    title: "Building Your First DApp: A Step-by-Step Guide",
    tags: ["Tutorial", "DApp"],
    readTime: "20 min",
    image: "/blog-dapp-guide.png",
  },
  {
    id: 5,
    title: "The Future of Cross-Chain Interoperability",
    tags: ["Technology", "Cross-Chain"],
    readTime: "10 min",
    image: "/blog-cross-chain.png",
  },
]

export default function BlogDetailPage() {
  const params = useParams()
  const router = useRouter()
  const [post, setPost] = useState<BlogPost | null>(null)
  const [loading, setLoading] = useState(true)
  const [liked, setLiked] = useState(false)
  const [bookmarked, setBookmarked] = useState(false)

  useEffect(() => {
    const postData = getBlogById(params.id as string)
    setPost(postData)
    setLoading(false)
  }, [params.id])

  if (loading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-primary"></div>
      </div>
    )
  }

  if (!post) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="text-center">
          <h1 className="text-2xl font-bold mb-4">Post Not Found</h1>
          <Button onClick={() => router.back()}>Go Back</Button>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="container mx-auto px-4 py-8 max-w-4xl">
        {/* Header */}
        <div className="flex items-center gap-4 mb-8">
          <Button variant="ghost" size="sm" onClick={() => router.back()}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to Blog
          </Button>
        </div>

        {/* Post Header */}
        <div className="mb-8">
          {post.featured && (
            <Badge variant="secondary" className="mb-4">
              Featured Post
            </Badge>
          )}

          <h1 className="text-4xl font-bold mb-4 text-balance">{post.title}</h1>

          <div className="flex items-center gap-6 text-muted-foreground mb-6">
            <div className="flex items-center gap-2">
              <User className="h-4 w-4" />
              <span>{post.author}</span>
            </div>
            <div className="flex items-center gap-2">
              <Clock className="h-4 w-4" />
              <span>{post.readTime}</span>
            </div>
            <div className="flex items-center gap-2">
              <Eye className="h-4 w-4" />
              <span>{post.views.toLocaleString()} views</span>
            </div>
            <span>{post.publishedAt}</span>
          </div>

          <div className="flex items-center gap-3 mb-6">
            <Button variant="outline" size="sm" onClick={() => setLiked(!liked)}>
              <ThumbsUp className={`h-4 w-4 mr-2 ${liked ? "fill-blue-500 text-blue-500" : ""}`} />
              {liked ? post.likes + 1 : post.likes}
            </Button>
            <Button variant="outline" size="sm" onClick={() => setBookmarked(!bookmarked)}>
              <Bookmark className={`h-4 w-4 mr-2 ${bookmarked ? "fill-yellow-500 text-yellow-500" : ""}`} />
              {bookmarked ? "Saved" : "Save"}
            </Button>
            <Button variant="outline" size="sm">
              <Share2 className="h-4 w-4 mr-2" />
              Share
            </Button>
          </div>
        </div>

        {/* Featured Image */}
        <div className="mb-8 rounded-xl overflow-hidden">
          <Image
            src={post.image || "/placeholder.svg"}
            alt={post.title}
            width={800}
            height={400}
            className="w-full h-auto"
          />
        </div>

        {/* Post Content */}
        <div className="grid grid-cols-1 lg:grid-cols-4 gap-8">
          <div className="lg:col-span-3">
            <div
              className="prose prose-lg max-w-none dark:prose-invert"
              dangerouslySetInnerHTML={{ __html: post.content }}
            />

            {/* Tags */}
            <div className="mt-8 pt-8 border-t border-border">
              <h3 className="text-lg font-semibold mb-4">Tags</h3>
              <div className="flex flex-wrap gap-2">
                {post.tags.map((tag) => (
                  <Badge key={tag} variant="outline">
                    {tag}
                  </Badge>
                ))}
              </div>
            </div>

            {/* Comments Section */}
            <div className="mt-8 pt-8 border-t border-border">
              <h3 className="text-xl font-semibold mb-6 flex items-center gap-2">
                <MessageCircle className="h-5 w-5" />
                Comments ({post.comments.length})
              </h3>

              <div className="space-y-6">
                {post.comments.map((comment) => (
                  <div key={comment.id} className="bg-card p-6 rounded-lg border">
                    <div className="flex items-center justify-between mb-3">
                      <div className="flex items-center gap-3">
                        <div className="w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center">
                          <User className="h-4 w-4 text-primary" />
                        </div>
                        <div>
                          <span className="font-medium">{comment.author}</span>
                          <div className="text-sm text-muted-foreground">{comment.publishedAt}</div>
                        </div>
                      </div>
                      <Button variant="ghost" size="sm">
                        <ThumbsUp className="h-4 w-4 mr-1" />
                        {comment.likes}
                      </Button>
                    </div>
                    <p className="text-muted-foreground">{comment.content}</p>
                  </div>
                ))}
              </div>

              {/* Add Comment */}
              <div className="mt-6 p-6 bg-card rounded-lg border">
                <h4 className="font-medium mb-4">Leave a Comment</h4>
                <div className="space-y-4">
                  <textarea
                    placeholder="Share your thoughts..."
                    className="w-full p-3 border border-border rounded-md bg-background resize-none"
                    rows={4}
                  />
                  <Button>Post Comment</Button>
                </div>
              </div>
            </div>
          </div>

          {/* Sidebar */}
          <div className="space-y-6">
            {/* Author Info */}
            <Card>
              <CardHeader>
                <CardTitle>About the Author</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="flex items-center gap-3 mb-4">
                  <div className="w-12 h-12 rounded-full bg-primary/10 flex items-center justify-center">
                    <User className="h-6 w-6 text-primary" />
                  </div>
                  <div>
                    <h4 className="font-semibold">{post.author}</h4>
                    <p className="text-sm text-muted-foreground">Blockchain Developer</p>
                  </div>
                </div>
                <p className="text-sm text-muted-foreground">
                  Experienced blockchain developer and technical writer with expertise in DeFi protocols and smart
                  contract security.
                </p>
              </CardContent>
            </Card>

            {/* Related Posts */}
            <Card>
              <CardHeader>
                <CardTitle>Related Posts</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  {relatedPosts.map((related) => (
                    <div key={related.id} className="group cursor-pointer">
                      <div className="flex gap-3">
                        <div className="w-16 h-16 rounded-lg overflow-hidden flex-shrink-0">
                          <Image
                            src={related.image || "/placeholder.svg"}
                            alt={related.title}
                            width={64}
                            height={64}
                            className="w-full h-full object-cover"
                          />
                        </div>
                        <div className="flex-1">
                          <h4 className="font-medium text-sm group-hover:text-primary transition-colors line-clamp-2">
                            {related.title}
                          </h4>
                          <div className="flex items-center gap-2 mt-1 text-xs text-muted-foreground">
                            <span>{related.readTime}</span>
                          </div>
                          <div className="flex flex-wrap gap-1 mt-2">
                            {related.tags.slice(0, 2).map((tag) => (
                              <Badge key={tag} variant="outline" className="text-xs">
                                {tag}
                              </Badge>
                            ))}
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  )
}
